---
attachments:
  [
    1206.png,
    1207.png,
    1208.png,
    1209.png,
    1210.png,
    1211.png,
    1212.png,
    1213.png,
    1214.png,
    1215.png,
    1216.png,
    1217.png,
    1218.png,
    1219.png,
    1220.png,
    1221.png,
    1222.png,
    1223.png,
    1224.png,
    1225.png,
    1226.png,
    1227.png,
    1228.png,
    1229.png,
    1230.png,
    1231.png,
    1232.png,
    1233.png,
    1234.png,
    1235.png,
    1236.png,
    1237.png,
    1238.png,
    1239.png,
    1240.png,
    1241.png,
    1242.png,
    1243.png,
    1244.png,
    1245.png,
    1246.png,
    1247.png,
    1248.png,
    1249.png,
    1250.png,
    1251.png,
    1252.png,
    1253.png,
    1254.png,
    1255.png,
    1256.png,
    1257.png,
    1258.png,
    1259.png,
    1260.png,
    1261.png,
    1262.png,
    1263.png,
    1264.png,
    1265.png,
    1266.png,
    1267.png,
    1268.png,
    1269.png,
    1270.png,
    1271.png,
    1272.png,
    1273.png,
    1274.png,
    1275.png,
    1276.png,
    1277.png,
    1278.png,
    1279.png,
    1280.png,
    1281.png,
    1282.png,
    1283.png,
    1284.png,
    1285.png,
    1286.png,
    1287.png,
    1288.png,
    1289.png,
    1290.png,
    1291.png,
    1292.png,
    1293.png,
    1294.png,
    1295.png,
    1296.png,
    1297.png,
    1298.png,
    1299.png,
    1300.png,
    1301.png,
    1302.png,
    1303.png,
    1304.png,
    1305.png,
    1306.png,
    1307.png,
    1308.png,
    1309.png,
    1310.png,
    1311.png,
    1312.png,
    1313.png,
    1314.png,
    1315.png,
    1316.png,
    1317.png,
    1318.png,
    1319.png,
    1320.png,
    1321.png,
    1322.png,
    1323.png,
    1324.png,
    1372.png,
    1373.png,
    1374.png,
    1375.png,
    1376.png,
    1377.png,
    1378.png,
  ]
title: Module 14 - ES Modules and Structuring Larger Apps
created: "2020-05-27T10:45:39.129Z"
modified: "2020-07-02T21:46:26.668Z"
---

- [Module 14 - ES Modules and Structuring Larger Apps](#module-14---es-modules-and-structuring-larger-apps)
  * [78 - Modules](#78---modules)
    + [What are Modules?](#what-are-modules-)
    + [Use Cases](#use-cases)
    + [Modules in the Browser](#modules-in-the-browser)
      - [In the Past - Sharing JavaScript Code between Files](#in-the-past---sharing-javascript-code-between-files)
      - [In the Present - Sharing JavaScript Code between Files](#in-the-present---sharing-javascript-code-between-files)
    + [Setting up Server](#setting-up-server)
    + [Importing and Exporting Modules](#importing-and-exporting-modules)
    + [Things we need to know about Modules](#things-we-need-to-know-about-modules)
      - [Scope](#scope)
      - [Difference between Default and Named Exports](#difference-between-default-and-named-exports)
    + [Renaming Modules](#renaming-modules)
    + [More Ways to Import](#more-ways-to-import)
    + [Loading Javascript On Demand](#loading-javascript-on-demand)
    + [async](#async)
  * [79 - Currency Module Refactor](#79---currency-module-refactor)
    + [Bootstrap / App Init Functions](#bootstrap---app-init-functions)
  * [80 - Dad Jokes Modules Refactor](#80---dad-jokes-modules-refactor)
    + [Refactoring into Modules](#refactoring-into-modules)
    + [Fixing Refactoring Errors](#fixing-refactoring-errors)
      - [Recap](#recap)
  * [81 - Bundling and Building with Parcel](#81---bundling-and-building-with-parcel)
      - [Benefits of Bundlers](#benefits-of-bundlers)
    + [Bundler Options / Alternatives](#bundler-options---alternatives)
    + [Using Parcel](#using-parcel)
      - [Dad Jokes Module](#dad-jokes-module)
      - [Installing Parcel](#installing-parcel)
      - [Adding an NPM Script to package.json](#adding-an-npm-script-to-packagejson)
    + [Building with Parcel](#building-with-parcel)
  * [82 - using open source npm packages](#82---using-open-source-npm-packages)
    + [node-modules folder](#node-modules-folder)
    + [Using Third Party Packages](#using-third-party-packages)
    + [Third Party Node Modules](#third-party-node-modules)
      - [waait npm package](#waait-npm-package)
      - [faker npm package](#faker-npm-package)
      - [CommonJS Syntax vs ECMA Script Modules import](#commonjs-syntax-vs-ecma-script-modules-import)
      - [date-fns npm package](#date-fns-npm-package)
      - [axios npm package](#axios-npm-package)
      - [lodash npm package](#lodash-npm-package)
      - [await-to-js](#await-to-js)
  * [83 - Security](#83---security)
    + [JavaScript is public](#javascript-is-public)
    + [XSS and Sanitizing your Inputs](#xss-and-sanitizing-your-inputs)
      - [FarceBook](#farcebook)
      - [Image Event Hijacking](#image-event-hijacking)
      - [Sanitizing User Data with DOMPurify.](#sanitizing-user-data-with-dompurify)
      - [HTTPS Origin](#https-origin)

---

# Module 14 - ES Modules and Structuring Larger Apps

## 78 - Modules

Let's talk about modules. Being able to share code across multiple javascript files and even across multiple projects is an easy thing to do when you start to use modules in Javascript.

### What are Modules?

So what are they?

**Modules** are a way to structure and organize your Javascript, and it gives us the ability to share functionality and data across multiple files and projects.

A few things you need to know about modules:

- They have their own scope, similar to how a function has scope.
- They can hold anything (functionality, data, config)

### Use Cases

If you recall in the previous lesson where we built a currency converter, we had a variable `currencies` that was a giant object of all the currency codes and names. It would be nice if instead of having that object directly in our file, we could put it in a separate module and then import it into the file to use when we need it. That is what modules will allow us to do.

Another use case for modules is utility functions.

For example, in the Dad Jokes lesson, we had a method `randomItemFromArray`. That method is not specific to that project, it's just a handy array utility. We could throw that off into a separate file that is used for utilities.

### Modules in the Browser

Let's look at how modules work in the browser, and then we will look at some tooling that will help us work with them.

You might hear modules referred to as **ESM**, **EcmaScript modules**, or **ES6 modules**. They were added to Javascript a couple of years ago, and they are the best way to organize your JavaScript when you have multiple files.

Let's go into our playground and create a folder called `modules` (it might already be there for you).

Inside that folder create the following files:

- `index.html`
- `utils.j`
- `handlers.js`
- `scripts.js`

That gives us 3 separate javascript files.

Add the following code to `scripts.js`.

```js
//scripts.js
const name = "wes";
```

In `utils.js`, add a simple function.

```js
//utils.js
function returnHi(name) {
  return `hi ${name}`;
}
```

Let's say we need to use the `returnHi` function in `scripts.js`. Can we do that if the function is in a separate javascript file than the one using it?

Let's try. Modify the code like so.

```js
//scripts.js
const name = 'wes';
console.log(returnHi(name)();
```

Go into `index.html` and add the base HTML if it is not already there as well as a script src tag and link it to `scripts.js`. Open the html page in the browser.

When you do that, you should see an error that `returnHi` is not defined.

![](./attachments/1206.png) 3:58

That makes sense Because we have not yet put our `utils` on the page.

You might think we can just add another script source tag above the one we added and link it to utils.

```html
<script src="./utils.js"></script>
<script src="./scripts.js"></script>
```

![](../attachments/1207.png) 4:27

As you can see, now it works. All we had to do is put one script in front of the other one that needed it in.

#### In the Past - Sharing JavaScript Code between Files

In the past, this was how code was shared across multiple files.

That got out of hand pretty quickly because you had all these files that had dependencies and the order of the script tags affected the execution because they all have to load in a waterfall, which means one after the other. Each file is assuming that the other one has access to it.

If you look at our `scripts.js` file in VS code, ESLint is complaining that `returnHi` is not defined. That is because that function does not exist within the file, so where did it come from?

The only reason it works is because we have globally scoped the function in another file and we are just assuming that it will be available to us on the page. That is a very brittle way to write JavaScript

#### In the Present - Sharing JavaScript Code between Files

The solution to that is to use modules!

When you need a function like `returnHi`, you can just import the function from the module, which is the same thing as saying from the file that actually contains that function.

When you do that, you don't really have to worry about things loading before each other, because we will always import the values we need before hand.

Let's change this example to use a very sime module.

In `index.html`, there is just have one script tag and that is going to be the entry point into the Javascript.

Add the `type` attribute on the script tag and set it to `module` like so 👇

```html
<scripts src="./scripts.js" type="module"></script>
```

Modify the code in `scripts.js` file to contain the following:

```js
const name = "wes";
console.log("Its working...");
```

If you refresh the HTML page and look at the console. you will should see a bunch of errors.

![](../attachments/1208.png) 7:11

This first one is the CORS issue again. It is giving us trouble because you cannot use modules unless you are running it on a server.

### Setting up Server

We cannot use a Parcel server because Parcel also handles modules for us and Wes is trying to show us how they work without using a bundler. We just need a very simple server up and running.

If you know how to run a server to serve us these files, feel free to skip ahead.=

There are a couple of different ways to do this.

1. VSCode plugin

If you go to extensions in VS code and search for "Live Server", you should see an extension that matches it and you can click install.

![](../attachments/1209.png) 8:13

If you go back to the modules and right click on the `index.html` and click open with Live server, and that will start it up in the browser.

![](../attachments/1210.png) 8:26

![](../attachments/1211.png) 8:34

That will start up a localhost server. The url is `127.0.0.1:5550` which is the equivalent as localhost, it is just the IP address. You can replace it with localhost and it will work just the same `localhost:5550`.

Now if you open up the dev tools, you will see that it is working.

2. BrowserSync

Another way to get a server running is to open your terminal and run `npm install -g browser-sync`.

![](../attachments/1212.png) 9:16

In the terminal, cd into the `modules/playground` folder and run the command`browser-sync`, it should start up a server.

![](../attachments/1213.png) 8:43

If you open up the dev tools, you will see it is working but we get an error regarding `base.css`.

![](../attachments/1214.png) 9:47

That is because we are running the server within our `/modules` folder but the base CSS file is actually at a higher level and it can't go up higher than the root.

The solution for that is to open up `base.css`, copy all the content and then make a new file within the `/modules` directory called `base.css`.

Now let's modify the path to that file within `index.html`. Modify it like so:

```
<link rel="stylesheet" href="./base.css">
```

Now if you refresh the page, you should no longer see that error.

At first it seemed like both of those options supported **hot reloading** or **live reloading**, which is the term used to refer to a feature where a server cause a browser to automatically refreshes the HTML page whenever a change is made to the HTML, CSS or JavaScript files.

However it seems like the way Wes is running browsersync isn't hot-reloading. It may be that the `browser-sync` command requires additional parameters to enable that but we will just stick to VSCode server since it is the simplest one.

Now that we have the server running, let's get back to the exercise and pick up where we left off.

How do we take a function that exists in one file and use it in another? You can import it from that file.

### Importing and Exporting Modules

There are two types of module imports:

1. **Named Imports**
2. **Default Imports**

Before we can import something, we first need to export it.

Let's go this by going to our `utils` file and exporting the `returnHi` function.

```js
function returnHi(name) {
  return `hi ${name}`;
}
```

When sharing code between multiple files like this, the word we use for each file is a module (so a file is a module).

If you want to surface functionality from one file to another, you first must export it. We will export it like this for now:

```js
export function returnHi(name) {
  return `hi ${name}`;
}
```

In `scripts.js`, let's go ahead and import that function now.

You do this by using the keyword `import`, a set of curly brackets between which you supply the name of the function we want to import, which is `returnHi` in this case and then we add the keyword "from" and the relative path to the file that contains the export, which is `utils` in this case.

```js
import { returnHi } from "./utils.js";
```

Now within `scripts.js`, we should be able to add the following code:

```Jokes
import { returnHi } from "./utils.js";

const name = "wes";
console.log(returnHi(name));
console.log("Its working....");
```

Now when the page refreshes, you will see that it is working.

![](../attachments/1215.png) 12:30

To recap:

We defined some functionality in a separate file but in order to in order to access that functionality, we must first export it from the file it is in.

Exporting it is a way of telling Javascript and the bundler that those functions or files are available to be used by other Javascript modules.

In a separate file, we imported that function and used it.

**You always do your imports at the very top of the file that you are in, and you can have multiple imports as well. Then you simply have access to that functionality and can use it.**

### Things we need to know about Modules

#### Scope

One thing that Wes mentioned briefly earlier is that modules have their own scope.

What does that mean? Let's look at an example to demonstrate.

Let's say we have the following variable within `utils.js`: `const last = 'bos';`.

What would happen if we want to access that within the `scripts.js` file like so:

```js
import { returnHi } from "./utils.js";

const name = "wes";
console.log(returnHi(name));
console.log("Its working....");
console.log(last);
```

When the HTML refreshes, you will see we get an error "last is not defined". That is because `last` is in a different module.

![](../attachments/1216.png) 13:38

What if within the `returnHi` function in `utils.js` we use the `last` variable like so 👇

```js
export function returnHi(name) {
  return `hi ${name} ${last}`;
}
```

Is that allowed? And is it going to work?

Let's find out.

Within our `scripts.js` remove `console.log(last)`.

![](../attachments/1217.png) 13:52

As you can see, it is working.

That means that you can use variables that are defined inside of a module, and they will not leak out and become available in any other file, however you can use them inside of that module, no problem.

That is what is referred to as _scoped to the module_.

The variable `last` would not available in the console if you were to try, because it is not globally scoped, and it is not available in the `scripts` module. The `last` variable is simply scoped to the `utils` file and can only be used within that file.

Is that good practice? Yes!

The beauty of modules is that you don't have to worry about scoping or anything like that.
You can just create variables inside of that file and they are only available inside of that file and nowhere else.

Now what if we _did_ want to be able to access the `last` variable inside of the `scripts` file? We could export that variable by putting the `export` keyword infront of the variable declaration.

```js
export const last = "bos";
```

Now within `scripts.js` we can modify our `import` statement to import that variable.

```
import { returnHi, last } from './utils.js';
```

At the bottom of `scripts.js` let's log `console.log(last)`.

![](../attachments/1218.png) 15:07

As you can see, that works!

Another way to export a value is instead of exporting it when you create it, you can export it from the bottom of the file like so `export { last }`. This is referred to as a named export because they have a name on them.

Here is what the `utils.js` file looks like now:

```js
//utils.js
const last = "bos";
export function returnHi(name) {
  return `Hi ${name} ${last}`;
}
//NAMED exports
export { last };
```

Let's say we have multiple variables like `const middle = 'slam dunk'` and we wanted to export that as well we could either add an `export` to the variable declaration or we can export middle using a named export like so:

```js
//utils.js
const last = "bos";
const middle = "slam dunk";
export function returnHi(name) {
  return `Hi ${name} ${last}`;
}
//NAMED exports
export { last, middle };
```

If you go into scripts and modify the file to import that variable and use it like so 👇

```js
//scripts.js
import { returnHi, last, middle } from "./utils.js";

const name = "wes";

console.log(returnHi(name));

console.log("Its working....");

console.log(last, middle);
```

![](../attachments/1219.png) 16:18

Which type of export should you use? That is a personal preference so use what you prefer. Wes often uses a combination of both.

You can also export async functions.

If `returnHi` were async, we could export it like so 👇

```js
export async function returnHi(name) {
  return `Hi ${name} ${last}`;
}
```

As mentioned earlier, that is what is referred to as **named exports** and **named imports**.

The way you can tell if something is a named export is if it has the `export` keyword in front of the function definition or variable declaration or if it is exported using curly brackets because those are only used in named exports.

The other way to do that is a called a **default export**.

Every module can have as many **named exports** as they want, however it can only have one **default export**, which specifies what is exported from the file by default.

For example, let's make another module `wes.json` and in it assign a variable `person` to an object, and then export that variable like so 👇

```js
const person = {
  name: "Wes",
  last: "Bos",
};

export default person;
```

Then if you want to access the `person` object within `scripts.js`, we could import it like so 👇

```js
import { returnHi, last, middle } from "./utils.js";
import wes from "./wes.js";
```

Now let's log it `console.log(wes)`.

![](../attachments/1220.png) 17:58

Now we could have named that import anything we wanted.

For example we could have done

```js
import { returnHi, last, middle } from "./utils.js";
import westerhoff from "./wes.js";

console.log(westerhoff);
```

If you refresh the page, you will see it still works.

#### Difference between Default and Named Exports

The difference between default exports and named exports is that with named imports, you must know what the name they have been exported as, but since there is only one default export per file, you can import them and name they whatever you want.

Which type of export should you use? There are arguments to be made on both sides.

Wes will usually use a default export if the module does one thing, but if the module does multiple things, like a utility library or something like that, then you can just have multiple named exports from it.

You can have both named and default exports in one file.

For example, in `utils.js`, we will default export a variable called `first`, by adding the following code to the bottom of the file 👇

```js
const first = "wes";
export default first;
```

Now within `scripts.js`, if we wanted to import that it wouldn't go in curly brackets because that is only for named and `first` is the default. So we could import and log it like so 👇

```js
import first, { returnHi, last, middle } from "./utils.js";
import westerhoff from "./wes.js";

console.log(westerhoff);
console.log(first);
```

![](../attachments/1221.png) 19:58

To reiterate:

- named are in curly brackets
- default are always only one and outside of the curly brackets.

### Renaming Modules

Another thing about modules is you can rename them as you import them.

Let's say we wanted to rename `returnHi` to `sayHi`. We could do that within the import statement like so 👇

```js
import first, { returnHi as sayHi, last, middle } from "./utils.js";
```

That will import `returnHi` and rename it to `sayHi`, kind of like destructuring but with different syntax because we use the `as` keyword.

Now let's replace where we are calling `returnHi` and instead call `sayHi`, and then log `sayHi`.

```js
import first, { returnHi as sayHi, last, middle } from "./utils.js";
import westerhoff from "./wes.js";

console.log(westerhoff);
console.log(sayHi);
console.log(first);

const name = "ws";

console.log(returnHi(name));

console.log("Its working...");

console.log(last, middle);
```

![](../attachments/1222.png) 20:39

As you can see, when we log `sayHi`, you see that we have that function there as `returnHi`.

Let's take a quick look at the docs. Google "mdn import".

![](../attachments/1223.png) 20:51

As you can see those are all the different types of imports.

Sometimes you will see people importing modules by leaving the `.js` off. Let's try that.

Remove the `.js` from the `utils` import statement like so:

```js
import first, { returnHi as sayHi, last, middle } from "./utils";
```

When you refresh the page, you will see we get an error.

![](../attachments/1225.png) 21:06

In a lot of bundlers, like Parcel, you can leave the end `.js` off, but that isn't part of the specs, so if you are using pure HTML-browser based loading, like we are, you must include it.

```js
import defaultExport from "module-name";
import * as name from "module-name";
import { export1 } from "module-name";
import { export1 as alias1 } from "module-name";
import { export1 , export2 } from "module-name";
import { foo , bar } from "module-name/path/to/specific/un-exported/file";
import { export1 , export2 as alias2 , [...] } from "module-name";
import defaultExport, { export1 [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";
import "module-name";
var promise = import("module-name");
```

Let's keep going through the different ways to import.

### More Ways to Import

`import * as name from 'module-name';`

You can import everything that comes in as a variable, like in the example above.

Let's go into `wes.js` and let's add the following code:

```js
const person = {
  name: "Wes",
  last: "Bos",
};

export default person;

export const dog = "Snickers";
export const food = "pizza";
export function eat() {
  console.log("chomp chomp");
}
```

It's important to know that you can import modules into any other modules, it's not limited to the entry point (which is `scripts.js` in our example).

Let's try something.

Let's take the three named exports (`dog`, `food` and `eat`), and import them into `scripts.js` by commenting out our existing import of `wes.js` and replacing it with `import * as everything` and then logging the value of `everything`.

```js
import first, { returnHi as sayHi, last, middle } from "./utils.js";
//import westerhoff from './wes.js';
import * as everything from "./wes.js";

//console.log(westerhoff);
console.log(everything);
console.log(sayHi);
console.log(first);

const name = "ws";

console.log(returnHi(name));

console.log("Its working...");

console.log(last, middle);
```

![](../attachments/1227.png) 23:05

If you look at the console you will see that we get this thing that kinda looks like an object but its called a module.

Inside of it we have:

- `default`
- `dog`
- `eat`
- `food`.

![](../attachments/1228.png) 23:25

That is useful when you want to import absolutely everything from a module.

You can also `import { export1 as alias } from 'module-name';`.

Wes will refer to these docs often but 99% of the time he will just use the `returnHi as sayHi` and that will cover you almost all of the time.

They also have docs for export where you can see how to export different types of expressions and objects and things like that (we will be covering some in the examples we do).

![](../attachments/1229.png) 24:16

The last thing we want to do is called an `on-demand` import.

```js
var promise = import("module-name");
```

That is handy when you want to import things only when you need them.

Let's go into the `/exercises/77 - Currency` folder and copy the big `currencies` object.

In the `modules` folder and create a new file called `currencies.js` and paste the copied object within the file.

If we try to export it as default by putting `export default` in front of the declaration, that will not work.

```js
export default const currencies = {..
```

If we want to export default a variable declaration, we must go to the bottom of the file and export it like so 👇

```js
export const currencies = {
  USD: "United States Dollar",
  AUD: "Australian Dollar",
  BGN: "Bulgarian Lev",
  BRL: "Brazilian Real",
  CAD: "Canadian Dollar",
  CHF: "Swiss Franc",
  CNY: "Chinese Yuan",
  CZK: "Czech Republic Koruna",
  DKK: "Danish Krone",
  GBP: "British Pound Sterling",
  HKD: "Hong Kong Dollar",
  HRK: "Croatian Kuna",
  HUF: "Hungarian Forint",
  IDR: "Indonesian Rupiah",
  ILS: "Israeli New Sheqel",
  INR: "Indian Rupee",
  JPY: "Japanese Yen",
  KRW: "South Korean Won",
  MXN: "Mexican Peso",
  MYR: "Malaysian Ringgit",
  NOK: "Norwegian Krone",
  NZD: "New Zealand Dollar",
  PHP: "Philippine Peso",
  PLN: "Polish Zloty",
  RON: "Romanian Leu",
  RUB: "Russian Ruble",
  SEK: "Swedish Krona",
  SGD: "Singapore Dollar",
  THB: "Thai Baht",
  TRY: "Turkish Lira",
  ZAR: "South African Rand",
  EUR: "Euro",
};

export default currencies;
```

Let's say we want to click a button and get all of the currencies.

One problem we might have is that it's too big of a file to load on homepage or when your scripts load.

It also might not be necessary to actually load the currencies.

### Loading Javascript On Demand

A popular thing to do is people will on-demand load Javascript.

For example, JavaScript for an online shopping cart will only be loaded when someone hovers over a buy now button. Or a list of counties might only be loaded when someone navigates to the checkout page.

Loading JavaScript on demand ensures that your website loads nice and fast because we are not loading JavaScript until we need it.

If we want to add a button to our page that when you click it, will load the currencies, it would work like so..

Go to the html and add a button right in the body tag.

```js
<body>
  <button>Load Currencies</button>
  <script src="./scripts.js" type="module"></scripts>
```

Next within `scripts.js`, remove everything but the code below to begin with 👇

```js
//scripts.js
import first, { returnHi as sayHi, last, middle } from "./utils.js";
import * as everything from "./wes.js";
```

We will begin by writing the code to select the button and listen for when it's clicked.

Instead of writing the handlers within this file, we will move them to a separate module.

Normally we would just go above the event listener and make a function like `handleButtonClick` or something that we would pass to it.

Instead, go into our `handlers.js` file and make a function called `handleButtonClick` which for now will just log the event, and export that.

```js
export function handleButtonClick(event) {
  console.log(event);
}
```

Back in `scripts.js` we need to import it now.

```js
import { handleButtonClick } from "./handlers.js";

const button = document.querySelector("button");
button.addEventListener("click", handleButtonClick);
```

This is normally how Wes structures his file. Typically he will have a JS file that will select his elements and hook up the event listeners, and then almost all his other utilities, data, functionality and handlers go in separate files/modules.

That allows Wes to import them as he needs them and that keeps `scripts.js` which is the entry point nice and lean. He can open the file and quickly get an idea of the functionality.

Then if he wants to know how something works, he needs to dig a bit further into the modules and read that.

If you refresh the HTML page and try clicking on the button, you will see the event logged.

![](../attachments/1230.png) 28:47

Now we can go to `handlers.js` and work on that function.

When the button is clicked, we want to get all the currencies. We could simply import them like so `import currencies from './currencies.js'`. Now within the function, let's log `currencies`.

If you do that, and refresh the page while the network tab is open, you will see all of the script modules that are being loaded.

![](../attachments/1231.png) 29:39

If you comment out that import statement and refresh the HTML page, you will see currencies is no longer in the network tab.

### async

How do we on-demand load some data or some functionality from a module? We can make it `async`.

```js
export async function handleButtonClick(event) {
  const currencies = await import("./currencies.js");
  console.log(currencies);
}
```

When the page refreshes, you will see that `currencies.js` is no longer loaded in the network tab until you click the button.

![](../attachments/1232.png) 30:15

![](../attachments/1233.png) 30:17

That request was only made after we clicked the button. Now we have the module logged in the console.

![](../attachments/1234.png) 30:30

If we want to access the currencies we need to get the default. Let's refactor the import slightly to rename the variable.

```js
export async function handleButtonClick(event) {
  const currenciesModule = await import("./currencies.js");
  console.log(currenciesModule.default);
}
```

When the page refreshes, you should see and have access to the currencies in the console.

![](../attachments/1235.png) 30:53

It does cache it, so if someone were to click the button again, the currencies would be loaded instantly instead of needing to be fetched again.

Let's say `currencies.js` had another export, such as `export const localCurrency = 'CAD'`.

How would we also import that on demand?

If you refresh the HTML page, you will see that we do have the `localCurrency` in the `module`.

![](../attachments/1236.png) 31:37

Let's destructure them into their own variables with curly brackets like so 👇

```js
const { localCurrency, default } = await import('./currencies.js');
console.log(localCurrency, default);
```

However if you try to do that, you will see the editor yelling at us that `default` is a reserved keyword, which means you cannot use it as a variable name.

To fix that, we need to rename it like so 👇

```js
const { localCurrency, default: currency } = await import("./currencies.js");
console.log(localCurrency, currency);
```

![](../attachments/1237.png) 32:21

When destructuring a property like `default` that is not allowed to be named `default`, we can use destructuring renaming syntax that looks like this: `default: currency`.

---

## 79 - Currency Module Refactor

In this lesson let's take the currency conversion example we did and convert it into modules.

Feel free to try this one yourself.

Go into our `/exercises` folder and find the folder containing the currency converter we built.

Duplicate that folder within the `/exercises` root and rename it to `79 - Currency Module Refactor`. Within that folder let's get rid of the `money-FINISHED.js` file.

Open `index.html` and add a `type="module"` to the script tag.

`money.js` will be our javascript entry point.

Before we start refactoring, let's take a look at the code we are working with. 👇

```js
const fromSelect = document.querySelector('[name="from_currency"]');
const fromInput = document.querySelector('[name="from_amount"]');
const toSelect = document.querySelector('[name="to_currency"]');
const toEl = document.querySelector(".to_amount");
const form = document.querySelector(".app form");
const endpoint = "https://api.exchangeratesapi.io/latest";
const ratesByBase = {};

const currencies = {
  USD: "United States Dollar",
  AUD: "Australian Dollar",
  BGN: "Bulgarian Lev",
  BRL: "Brazilian Real",
  CAD: "Canadian Dollar",
  CHF: "Swiss Franc",
  CNY: "Chinese Yuan",
  CZK: "Czech Republic Koruna",
  DKK: "Danish Krone",
  GBP: "British Pound Sterling",
  HKD: "Hong Kong Dollar",
  HRK: "Croatian Kuna",
  HUF: "Hungarian Forint",
  IDR: "Indonesian Rupiah",
  ILS: "Israeli New Sheqel",
  INR: "Indian Rupee",
  JPY: "Japanese Yen",
  KRW: "South Korean Won",
  MXN: "Mexican Peso",
  MYR: "Malaysian Ringgit",
  NOK: "Norwegian Krone",
  NZD: "New Zealand Dollar",
  PHP: "Philippine Peso",
  PLN: "Polish Zloty",
  RON: "Romanian Leu",
  RUB: "Russian Ruble",
  SEK: "Swedish Krona",
  SGD: "Singapore Dollar",
  THB: "Thai Baht",
  TRY: "Turkish Lira",
  ZAR: "South African Rand",
  EUR: "Euro",
};

function generateOptions(options) {
  return Object.entries(options)
    .map(
      ([currencyCode, currencyName]) =>
        `<option value="${currencyCode}">${currencyCode} - ${currencyName}</option>`
    )
    .join("");
}

async function fetchRates(base = "USD") {
  const res = await fetch(`${endpoint}?base=${base}`);
  const rates = await res.json();
  return rates;
}

async function convert(amount, from, to) {
  // first check if we even have the rates to convert from that currency
  if (!ratesByBase[from]) {
    console.log(
      `Oh no, we dont have ${from} to convert to ${to}. So gets go get it!`
    );
    const rates = await fetchRates(from);
    console.log(rates);
    // store them for next time
    ratesByBase[from] = rates;
  }
  // convert that amount that they passed it
  const rate = ratesByBase[from].rates[to];
  const convertedAmount = rate * amount;
  console.log(`${amount} ${from} is ${convertedAmount} in ${to}`);
  return convertedAmount;
}

function formatCurrency(amount, currency) {
  return Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(amount);
}
async function handleInput(e) {
  const rawAmount = await convert(
    fromInput.value,
    fromSelect.value,
    toSelect.value
  );
  toEl.textContent = formatCurrency(rawAmount, toSelect.value);
}

const optionsHTML = generateOptions(currencies);
// populate the options elements
fromSelect.innerHTML = optionsHTML;
toSelect.innerHTML = optionsHTML;

form.addEventListener("input", handleInput);
```

Within the file: ...

- Selecting a bunch of elements and have a `ratesByBase` and `currencies` object.

- Have a few functions such as `generateOptions`, `fetchRates` which require the endpoint, and we have a `convert`, `formatCurrency` function plus one handler.

- have **library functions** which are functions that are considered core to our application such as a few handlers, and `generateOptions` which is a helper/utility method, and we also have some data.

For this example, we won't use any folder structure. Instead Wes will show you how to do it with a **flat file structure**.

Within the `79 - Currency Refactor` folder create a file called `currencies.js` and paste the entire `currencies` object within it. It is a big enough object that Wes would give it it's own file.

```js
//currencies.js

const currencies = {
  USD: "United States Dollar",
  AUD: "Australian Dollar",
  BGN: "Bulgarian Lev",
  BRL: "Brazilian Real",
  CAD: "Canadian Dollar",
  CHF: "Swiss Franc",
  CNY: "Chinese Yuan",
  CZK: "Czech Republic Koruna",
  DKK: "Danish Krone",
  GBP: "British Pound Sterling",
  HKD: "Hong Kong Dollar",
  HRK: "Croatian Kuna",
  HUF: "Hungarian Forint",
  IDR: "Indonesian Rupiah",
  ILS: "Israeli New Sheqel",
  INR: "Indian Rupee",
  JPY: "Japanese Yen",
  KRW: "South Korean Won",
  MXN: "Mexican Peso",
  MYR: "Malaysian Ringgit",
  NOK: "Norwegian Krone",
  NZD: "New Zealand Dollar",
  PHP: "Philippine Peso",
  PLN: "Polish Zloty",
  RON: "Romanian Leu",
  RUB: "Russian Ruble",
  SEK: "Swedish Krona",
  SGD: "Singapore Dollar",
  THB: "Thai Baht",
  TRY: "Turkish Lira",
  ZAR: "South African Rand",
  EUR: "Euro",
};

export default currencies;
```

Make a new file called `utils.js` and inside of that we will paste our `generateOptions` method and make it a named export.

```js
//utils.js
export function generateOptions(options) {
  return Object.entries(options)
    .map(
      ([currencyCode, currencyName]) =>
        `<option value="${currencyCode}">${currencyCode} - ${currencyName}</option>`
    )
    .join("");
}
```

Next make another file called `lib.js`. Move the `fetchRates` and `convert` functions to that file.

```js
//lib.js
export async function fetchRates(base = "USD") {
  const res = await fetch(`${endpoint}?base=${base}`);
  const rates = await res.json();
  return rates;
}

export async function convert(amount, from, to) {
  // first check if we even have the rates to convert from that currency
  if (!ratesByBase[from]) {
    console.log(
      `Oh no, we don't have ${from} to convert to ${to}. So gets go get it!`
    );
    const rates = await fetchRates(from);
    console.log(rates);
    // store them for next time
    ratesByBase[from] = rates;
  }
  // convert that amount that they passed it
  const rate = ratesByBase[from].rates[to];
  const convertedAmount = rate * amount;
  console.log(`${amount} ${from} is ${convertedAmount} in ${to}`);
  return convertedAmount;
}
```

Take the next function `formatCurrency` and put it in the `utils.js` file like so 👇

```js
//utils.js
export function generateOptions(options) {
  return Object.entries(options)
    .map(
      ([currencyCode, currencyName]) =>
        `<option value="${currencyCode}">${currencyCode} - ${currencyName}</option>`
    )
    .join("");
}
export function formatCurrency(amount, currency) {
  return Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(amount);
}
```

Next there is `handleInput` which is a handler, so make a new file called `handlers.js` and add that there.

```js
export sync function handleInput(e) {
  const rawAmount = await convert(
    fromInput.value,
    fromSelect.value,
    toSelect.value
  );
  toEl.textContent = formatCurrency(rawAmount, toSelect.value);
}
```

You should be left with the following code in `money.js`.

```js
//money.js
const fromSelect = document.querySelector('[name="from_currency"]');
const fromInput = document.querySelector('[name="from_amount"]');
const toSelect = document.querySelector('[name="to_currency"]');
const toEl = document.querySelector(".to_amount");
const form = document.querySelector(".app form");
const endpoint = "https://api.exchangeratesapi.io/latest";
const ratesByBase = {};

const optionsHTML = generateOptions(currencies);
// populate the options elements
fromSelect.innerHTML = optionsHTML;
toSelect.innerHTML = optionsHTML;

form.addEventListener("input", handleInput);
```

Now the code that is left is only responsible for:

- generating the options and initializing them on page load on page load
- adding the event listeners

Let's start by going through them one by one and deciding whether or not to move it out of `money.js`.

Open up `index.html` in a VSCode live server and look to see if we have any errors in the console.

![](../attachments/1238.png) 4:07

It is complaining that `generateOptions` is not defined. Let's import it.

```js
import { generateOptions } from "./utils.js";
```

Next we get an error saying `currencies` is not defined.

![](../attachments/1239.png) 4:25

Import `currencies` so we can pass it to `generateOptions`.

```js
import { generateOptions } from "./utils.js";
import { currencies } from "./currencies.js";
```

WHen the page refreshes, we have yet another error. It is complaining that it cannot find an export named `currencies`.

![](../attachments/1240.png) 4:43

That is because it is a default export, not a named export, so it doesn't need the curly brackets.

Modify it like so 👇

```js
import currencies from './currencies.js';
```

Now the console is complaining that `handleInput` is not defined.

![](../attachments/1241.png) 4:59

Let's fix that by adding `import { handleInput } from './handlers';`

Finally there are no more errors in the console, until you try to type an amount into the input. When you try this you will see a reference error in the console complaining that `convert` is not defined, and it is happening in `handlers.js` on line 2.

![](../attachments/1242.png) 5:25

To fix that, import the `convert` function into `handlers`.

```js
import { convert } from "./lib.js";
export sync function handleInput(e) {
  const rawAmount = await convert(
    fromInput.value,
    fromSelect.value,
    toSelect.value
  );
  toEl.textContent = formatCurrency(rawAmount, toSelect.value);
}
```

![](../attachments/1244.png) 5:55

Now we get another error that `fromInput` is not defined. Within `handleInput` use the `fromInput`, `fromSelect`, `toSelect` and `toEl` variables.

We also reference the function `formatCurrency` which we haven't imported.

Import it to `handlers.js` like so `import { formatCurrency } from "./utils";`

We need all those elements, and rather than pass them in as an argument to the function, let's put them in their own module.

Create a new file called `elements.js`.

Go into `money.js` and take all the selectors and move them to the new `elements.js` file. Add the export keyword in front of each like so 👇

```js
//elements.js
export const fromSelect = document.querySelector('[name="from_currency"]');
export const fromInput = document.querySelector('[name="from_amount"]');
export const toSelect = document.querySelector('[name="to_currency"]');
export const toEl = document.querySelector(".to_amount");
```

![](../attachments/1245.png) 6:53

What people will often do is instead of using `document.querySelector` for all of those, they will grab a parent element like the div with a class of `app` in the example above, and then look for the selectors inside of there.

You would have `app.querySelector` for each of those instead which allows you to have multiple on the same page, just like we did with the slider.

The way we are doing it is fine for now.

If you refresh the page, we have an error `fromSelect` is not defined.

![](../attachments/1246.png) 7:11

Let's first go into `handlers` and import those elements.

```js
import { convert } from "./lib.js";
import { formatCurrency } from "./utils.js";
import { fromInput, fromSelect, toSelect, toEl } from "./elements.js";

export async function handleInput(e) {
  const rawAmount = await convert(
    fromInput.value,
    fromSelect.value,
    toSelect.value
  );
  toEl.textContent = formatCurrency(rawAmount, toSelect.value);
}
```

Let's tackle the `fromSelect` is not defined issue happening in `money.js` on line 11.

![](../attachments/1247.png) 7:44

As you can see, `fromSelect` and `toSelect` are also needed from `money.js` on page load. Let's go ahead and import them.

```js
//money.js
import { generateOptions } from "./utils.js";
import currencies from "./currencies.js";
import { handleInput } from "./handlers.js";
import { fromSelect, toSelect } from "./elements.js";

const form = document.querySelector(".app form");
const endpoint = "https://api.exchangeratesapi.io/latest";
const ratesByBase = {};

const optionsHTML = generateOptions(currencies);
// populate the options elements
fromSelect.innerHTML = optionsHTML;
toSelect.innerHTML = optionsHTML;

form.addEventListener("input", handleInput);
```

When the page is now refreshed, we are getting an error that ratesByBase is not defined.

![](../attachments/1248.png) 8:07

Our `endpoint` and `ratesByBase` variables need to go in our `lib.js` file.

Copy those over to the lib.js file.

```js
//lib.js
const endpoint = "https://api.exchangeratesapi.io/latest";
const ratesByBase = {};

export async function fetchRates(base = "USD") {
  const res = await fetch(`${endpoint}?base=${base}`);
  const rates = await res.json();
  return rates;
}

export async function convert(amount, from, to) {
  // first check if we even have the rates to convert from that currency
  if (!ratesByBase[from]) {
    console.log(
      `Oh no, we dont have ${from} to convert to ${to}. So gets go get it!`
    );
    const rates = await fetchRates(from);
    console.log(rates);
    // store them for next time
    ratesByBase[from] = rates;
  }
  // convert that amount that they passed it
  const rate = ratesByBase[from].rates[to];
  const convertedAmount = rate * amount;
  console.log(`${amount} ${from} is ${convertedAmount} in ${to}`);
  return convertedAmount;
}
```

When the page is refreshed, you will see that it is now working! Feel free to play around with the app to test it.

That was simpler than Wes expected -- he thought dealing with the `ratesByBase` variable would be tricky because we are updating it.

However, the beauty of module scope is that inside of the module, we can create the `ratesByBase` object and update it from our `convert` function. Even though we are calling the `convert` from another file, it still knows about the scope of the file (similar to how a closure works), so we can still access it without issues.

The only gotcha about these modules is that if you are on a server, the `ratesByBase` will be shared by every request that comes in which may or may not be what you want.

Wes has ran into an issue where Wes was storing data in one module that was being overwritten by multiple users. If that is the case, you need to get into sessions or scope it to each function but in our case, and most cases ,this is fine.

We have refactored the entire app into modules, which makes it a bit more organized to work with and more modular.

### Bootstrap / App Init Functions

One more thing Wes wants to show us is a situation where we might take the form element and put it into a bootstrap or app init function. What does that mean?

All of this code in `money.js` runs on page load.

```js
//when the page loads, this code runs
const form = document.querySelector(".app form");

const optionsHTML = generateOptions(currencies);
// populate the options elements
fromSelect.innerHTML = optionsHTML;
toSelect.innerHTML = optionsHTML;

form.addEventListener("input", handleInput);
```

Sometimes you might want to delay the running of what happens on page load.

If that is the case, what we would do is take all that logic from `money.js` and go to `lib.js` and make another function like so 👇

```js
//lib.js
export function init() {
  // when the page loads, this code runs
  const form = document.querySelector(".app form");

  const optionsHTML = generateOptions(currencies);
  // populate the options elements
  fromSelect.innerHTML = optionsHTML;
  toSelect.innerHTML = optionsHTML;

  form.addEventListener("input", handleInput);
}
```

We also need to import `fromSelect` and `toSelect`.

Add the following import 👇statement to the other imports at the top of `libs.js`.

```js
import { fromSelect, toSelect } from "./elements.js";
```

If you try to play around with the app now, nothing happens because no code has started.

To fix that go back to`money.js`, and import that `init` function and use it to start the app.

```js
import { generateOptions } from "./utils.js";
import currencies from "./currencies.js";
import { handleInput } from "./handlers.js";
import { fromSelect, toSelect } from "./elements.js";
import { init } from "./lib.js";

init();
```

If you refresh the page now, you will see the following error complaining that `generateOptions` is not defined.

![](../attachments/1249.png) 11:42

We need to go to `lib.js` and import `generateOptions`.

```js
import { fromSelect, toSelect } from "./elements.js";
import { generateOptions } from "./utils.js";
```

Now if we refresh it is complaining about `currencies` not being defined.

![](../attachments/1250.png) 12:17

What we can do is go to `money.js` and take all our import statements except for the `init` import and move them to `lib.js`.

```js
import { fromSelect, toSelect } from "./elements.js";
import { generateOptions } from "./utils.js";
import currencies from "./currencies.js";
import { handleInput } from "./handlers.js";
```

Wes' ESLint is complaining about the `handleInput` import. The error says "Dependency cycle detected".

![](../attachments/1251.png) 12:39

If you look at our `handlers.js`, we are importing `convert` from there from `lib`. So both files require each other. That could cause you to end up with a situation where they require each other and it gets out of control.

For our purposes, it is working, but let's fix that anyway.

Create one more file called `init.js`

Take the `init` function and all the imports added out of `lib.js` and put it in our `init.js` file instead.

```js
//init.js

import { fromSelect, toSelect } from "./elements.js";
import { generateOptions } from "./utils.js";
import currencies from "./currencies.js";
import { handleInput } from "./handlers.js";

export function init() {
  // when the page loads, this code runs
  const form = document.querySelector(".app form");

  const optionsHTML = generateOptions(currencies);
  // populate the options elements
  fromSelect.innerHTML = optionsHTML;
  toSelect.innerHTML = optionsHTML;

  form.addEventListener("input", handleInput);
}
```

In `money.js`, modify the code to import from `init.js` instead.

```js
//money.js
import { init } from "./init.js";

init();
```

If you refresh the page and play with the app, you will see that it is working!

You could go one step further and not even run the code unless someone clicks a button or hovers over it.

To do that, select the div with class of app within `money.js`.

Pass the event listener to our `init` function to call, and pass it the options object to the event listener to specify we only want it to run once, like so 👇

```js
import { init } from "./init.js";

const app = document.querySelector(".app");

app.addEventListener("mouseenter", init, { once: true });
```

When the page loads, it should just say "Select a Currency" until you hover over the form, and then the code initializes and the base currency is switched out to USD.

![](../attachments/1252.png) 14:26

Now our entry point has almost nothing in it because it is in a separate file.

Is that okay?

Yes, some people like their entry point to have a little code but you could have also left all the code in `money.js` as well and it still would have worked!

---

## 80 - Dad Jokes Modules Refactor

In this lesson we will refactor our dad jokes exercise so you can see how Wes would structure it.

1. Start by duplicating the `76 - Dad Jokes` folder within the `exercises/` directory and renaming it to `80 - Dad Jokes Modules`.

2. Take all the code in `jokes-FINISHED.js` and put it `jokes.js` and then delete the finished version of the file.

3. Convert this exercise to use modules by first putting an attribute of `type="module"` on the script tag on the HTML page.

4. Run the exercise under a server which we can do in VSCode by right clicking the file in VSCode and selecting "open with live server".

Now when the server loads, the dad jokes app should be working as expected.

Let's start the refactor by first looking at the code within `jokes.js`, and then we can begin splitting it out line by line, function by function.

```js
//jokes.js
const jokeButton = document.querySelector(".getJoke");
const jokeButtonSpan = jokeButton.querySelector(".jokeText");
const jokeHolder = document.querySelector(".joke p");
const loader = document.querySelector(".loader");

const buttonText = [
  "Ugh.",
  "🤦🏻‍♂️",
  "omg dad.",
  "you are the worst",
  "seriously",
  "stop it.",
  "please stop",
  "that was the worst one",
];

async function fetchJoke() {
  // turn loader on
  loader.classList.remove("hidden");
  const response = await fetch("https://icanhazdadjoke.com", {
    headers: {
      Accept: "application/json",
    },
  });
  const data = await response.json();
  // turn the loader off
  loader.classList.add("hidden");
  return data;
}

function randomItemFromArray(arr, not) {
  const item = arr[Math.floor(Math.random() * arr.length)];
  if (item === not) {
    console.log("Ahh we used that one last time, look again");
    return randomItemFromArray(arr, not);
  }
  return item;
}

async function handleClick() {
  const { joke } = await fetchJoke();
  jokeHolder.textContent = joke;
  jokeButtonSpan.textContent = randomItemFromArray(
    buttonText,
    jokeButtonSpan.textContent
  );
}

jokeButton.addEventListener("click", handleClick);
```

### Refactoring into Modules

The entry point to our JavaScript will be `jokes.js` because that is what we have linked on the HTML page.

In the entry point, Wes like to do his selecting and event listeners but everything else, all of the data, functionality, utilities and handlers will all be in separate files in their own modules. We will use this approach.

Starting at the top of `jokes.js`, the first 4 lines of code are simply selecting elements, so let's leave those for now.

Where should we put the `buttonText` variable?

Sometimes people will organize their code into folders, so to demonstrate that, we will put this in a folder called `data`, which you need to create.

Within the folder, add a file called `buttonText.js`. Copy and paste the buttonText variable in that file.

_We will worry about importing and exporting these functions between modules later, for now we just want to get all of the different functions into their own files._

Next is the `fetchJoke` function.

That is core to what the application does so often people will make a `lib` folder for this. Make that folder.

_(Note: you don't have to do this, Wes personally finds it confusing when people have hundreds of folders for organization sakes. Feel free to just make files in the root directory or organize your files however you like. Wes suggests starting simple and the coming back and refactoring if you need more organization.)_

Within that new folder, create a file `index.js` which will contain all of the library JavaScript.

Copy and cut the `fetchJoke` function into the `index.js` file.

![](../attachments/1253.png) 3:31

Once you do that, you may notice that in your VSCode that the loader variable within `fetchJokes` is underlined as red. VSCode is complaining because the function requires the loader, but we have not passed it a reference to the loader in this file. Due to modules have their own scope, we are no longer able to reference the `loader` variable from the `jokes.js` module.

There are 2 ways we can fix this:

- we can either select the loader within that function
- we can pass it in as a parameter.

We will pass it as a parameter, and export the function as a named function.

```js
//lib/index.js
//named export, you can have lots of these
export async function fetchJoke(loader) {
  // turn loader on
  loader.classList.remove("hidden");
  const response = await fetch("https://icanhazdadjoke.com", {
    headers: {
      Accept: "application/json",
    },
  });
  const data = await response.json();
  // turn the loader off
  loader.classList.add("hidden");
  return data;
}
```

Next modify the function that calls `fetchJoke` so it can pass the loader 👇

```js
//money.js
async function handleClick() {
  const { joke } = await fetchJoke(loader);
  jokeHolder.textContent = joke;
  jokeButtonSpan.textContent = randomItemFromArray(
    buttonText,
    jokeButtonSpan.textContent
  );
}
```

Earlier when we created the `buttonText` file, we forgot to export it. Go back to `buttonText` and make it a default export.

```js
//data/buttonText.js
const buttonText = [
  "Ugh.",
  "🤦🏻‍♂️",
  "omg dad.",
  "you are the worst",
  "seriously",
  "stop it.",
  "please stop",
  "that was the worst one",
];

//default export, you can only have one.
export default buttonText;
```

Why did we put the `buttonText` in it's own file? Unlike with the `index.js` file and `lib` folders which may contain multiple functions, `buttonText.js` is likely not doing to have any other functionality, so we can just make it the default export of it's own file.

The next function is `randomItemFromArray`, which is a utility function. Inside of the `lib` folder, create the file `utils.js`.

People will often make an entire folder dedicated to utils, it doesn't matter, go with what you prefer. Wes likes to make a `utils.js` file and stick anything in there and then if it gets too large, he will break it up into separate functions. We will go with that approach.

```js
//lib/utils.js
//named export
export function randomItemFromArray(arr, not) {
  const item = arr[Math.floor(Math.random() * arr.length)];
  if (item === not) {
    console.log("Ahh we used that one last time, look again");
    return randomItemFromArray(arr, not);
  }
  return item;
}
```

Next up is `handleClick`.

Make another file in `lib` called `handlers.js`. Copy and cut the `handleClick` function out of `jokes.js` and put it the new file.

```js
//lib/handlers.js
//named export
async function handleClick() {
  const { joke } = await fetchJoke();
  jokeHolder.textContent = joke;
  jokeButtonSpan.textContent = randomItemFromArray(
    buttonText,
    jokeButtonSpan.textContent
  );
}
```

### Fixing Refactoring Errors

At this stage of the refactor, the code will be pretty broken.

Wes approaches it either by going through the errors in the console, or by ESLint errors. We will go with the former.

If you open the console, the first error you should see in the console is a reference error warning that `handleClick` is not defined.

![](../attachments/1254.png)

Earlier we moved `handleClick` into our `handlers.js` module. Now if we need to access the function in another file, we must first import it, like so 👇

```js
//jokes.js
import { handleClick } from "./lib/handlers.js";

const jokeButton = document.querySelector(".getJoke");
const jokeButtonSpan = jokeButton.querySelector(".jokeText");
const jokeHolder = document.querySelector(".joke p");
const loader = document.querySelector(".loader");

jokeButton.addEventListener("click", handleClick);
```

When the page refreshes now, the console is not showing any errors but if you click the button, you should see an error logged complaining that `fetchJoke` is not defined.

![](../attachments/1255.png) 7:19

![](../attachments/1256.png) 7:27

As you can see above, the `fetchJoke` function is used within `handleClick`. How do we make it available within `handleClick`?

Do we....

- import `fetchJoke` in our `jokes.js` entry point?

or

- import `fetchJokes` into our `handlers.js` module?

The answer is you always import it where you need it, even if you have already imported it into another file.

For example, even if we imported `fetchJoke` in `jokes.js` and tried to refresh the page and click the button, we would see get the error `fetchJoke` is not defined.

Why is that?

Even though we imported it into our entry, we still have to import it where we need it to give the other modules reference to it.

There is no point of importing it into our entry file right now because we are not using it anywhere in the page. _There is no sense in importing things into a file where they are not used._

You simply import it where you need it. Go ahead and do that in `handlers.js`.

```js
//lib/handlers.js
import { fetchJoke } from "./index.js";
//named export
async function handleClick() {
  const { joke } = await fetchJoke();
  jokeHolder.textContent = joke;
  jokeButtonSpan.textContent = randomItemFromArray(
    buttonText,
    jokeButtonSpan.textContent
  );
}
```

![](../attachments/1257.png) 8:54

The next error is complaining that loader is not defined within `handlers.js`.

Earlier we modified the `fetchJoke` function to accept a reference to the loader, but now we are calling it from a separate file.

How do we pass it? We can pass it as an argument to `handleClick` like so 👇

```js
//jokes.js
import { handleClick } from "./lib/handlers.js";

const jokeButton = document.querySelector(".getJoke");
const jokeButtonSpan = jokeButton.querySelector(".jokeText");
const jokeHolder = document.querySelector(".joke p");
const loader = document.querySelector(".loader");

jokeButton.addEventListener("click", () => handleClick(loader));
```

![](../attachments/1258.png) 9:32

However, the console is still complaining that it loader.

That is because we have to modify our `handleClick` function to accept the `loader` reference as a parameter, like so 👇

```js
//lib/handlers.js
import { fetchJoke } from "./index.js";
//named export
async function handleClick(loader) {
  const { joke } = await fetchJoke();
  jokeHolder.textContent = joke;
  jokeButtonSpan.textContent = randomItemFromArray(
    buttonText,
    jokeButtonSpan.textContent
  );
}
```

![](../attachments/1259.png) 9:43

The loader is showing up now!

An alternative solution would have been to add `jokeButton.addEventListener('click', handleClick.bind(null, loader))` to `jokes.js`.

In that example, we are passing null to `bind` because we don't care about `this` as we are not using it, and then we can pass it the loader as an argument.

Another alternative would have been to have a regular function that will call `handleClick`. We will use an anonymous function.

```js
jokeButton.addEventListener("click", function () {
  handleClick(loader);
});
```

Sometimes you have to pass things around like we are with the `loader`. We selected it in `jokes.js`, passed it to `handleClick`, and then from `handleClick` we passed it to `fetchJoke`. We could have also selected it right inside of `handleClick` as well, it is up to you to choose an approach.

![](../attachments/1260.png) 10:46

Now that the loader is showing up, let's move onto the next error.

The console is complaining that `jokeHolder` is not defined within `handlers.js`.

This refactor is a bit trickier because `handleClick` needs the `loader`, the `jokeButtonSpan` and the `jokeHolder`.

Do we modify `handleClick` to take two more arguments?

Instead of doing that, let's solve the issue by creating another module that will do all of our selecting.

Go into our `lib` folder and create a file called `elements.js`. Copy all the `querySelectors` from `jokes.js` and paste them into `elements.js`. Add an export in front of each.

```js
// elements.js

export const jokeButton = document.querySelector(".getJoke");
export const jokeButtonSpan = jokeButton.querySelector(".jokeText");
export const jokeHolder = document.querySelector(".joke p");
export const loader = document.querySelector(".loader");
```

We no longer have to pass the loader. Modify the call to `handleClick` in `jokes.js`, and also import the `jokeButton`.

```js
//jokes.js
import { handleClick } from "./lib/handlers.js";
import { jokeButton } from "./lib/elements.js";

jokeButton.addEventListener("click", handleClick);
```

Next we will go into `handlers.js` and fix that file.

We no longer have to pass the loader to `handleClick` so remove that parameter.

Take the `loader`, `jokeHolder`, `jokeButtonSpan` and import them.

```js
//handlers.js
import { loader, jokeHolder, jokeButtonSpan } from "elements.js";
import { fetchJoke } from "./index.js";

export async function handleClick() {
  const { joke } = await fetchJoke();
  jokeHolder.textContent = joke;
  jokeButtonSpan.textContent = randomItemFromArray(
    buttonText,
    jokeButtonSpan.textContent
  );
}
```

Now when you press the button, it will fetch a joke and display it but we get another error in the console.

![](../attachments/1261.png) 12:31

Now it's complaining that `randomItemFromArray` is not defined in `handlers.js`. Import it from `utils.js`. 👇

```js
// handlers.js
import { loader, jokeHolder, jokeButtonSpan } from "elements.js";
import { fetchJoke } from "./index.js";
import { randomItemFromArray } from "./utils.js";

export async function handleClick() {
  const { joke } = await fetchJoke();
  jokeHolder.textContent = joke;
  jokeButtonSpan.textContent = randomItemFromArray(
    buttonText,
    jokeButtonSpan.textContent
  );
}
```

When the page refreshes, if you try it again, you will see another error ,this time about `buttonText` not being defined. Import `buttonText` 👇

![](../attachments/1262.png) 12:53

```js
// handlers.js
import { loader, jokeHolder, jokeButtonSpan } from "elements.js";
import { fetchJoke } from "./index.js";
import { randomItemFromArray } from "./utils.js";
import buttonText from "../data/buttonText.js";

export async function handleClick() {
  const { joke } = await fetchJoke();
  jokeHolder.textContent = joke;
  jokeButtonSpan.textContent = randomItemFromArray(
    buttonText,
    jokeButtonSpan.textContent
  );
}
```

Now if you try it, it will work!

#### Recap

So in this lesson we chopped up the code into separate files.

Sometimes for beginners it may seem harder to do it this way because everything is in different files and you don't know where to look for things.

That is where you need to get good at following the stack trace and seeing where errors go.

It is much better for maintainability and shareability to go with this approach than having it all in one file.

---

## 81 - Bundling and Building with Parcel

So the idea with modules is eventually we will be able to ship this script tag to the browser.

Meaning we can upload our entire project and the idea is we have this thing `HTTP2` and `HTTP3`, which even though you are requesting multiple files, they can all be delivered at once.

Your server will know exactly what Javascript files to deliver to you.

That currently isn't the situation and most developers will each for what is called a **bundler**.

Why might someone use a bundler over a regular module?

#### Benefits of Bundlers

There are a few benefits.

- a bundler is able to compress all your code.
- bundler will minify all the code. The way **minification** works is longer variables are replaces with shorter ones to save space. For example `options` would be replaced with `o`.
- make your code as small as possible.
- **dead-code elimination** - if you have a function that is never used, it will detect that and remove that.

### Bundler Options / Alternatives

We talked about **Babel** earlier, which will transpile newer javascript code and syntax into javascript that older browsers will recognize. It will also handle things like Javascript, **SASS** or **LESS**, or some of the newer **CSS auto-prefixer** stuff.

There are a bunch of different bundlers out there, and generally a bundler will include both a bundler and a dev server. In this course, whenever we used the command `parcel start`, that was to start the dev server that is part of the Parcel bundlers.

![](../attachments/1263.png) 2:20

Parcel is a popular bundler.

There is a new one called Pika which is newer.

![](../attachments/1264.png) 2:28

Webpack is the most popular one at the moment, but hard to get up and running in Wes' opinion.

![](../attachments/1265.png) 2:32

Both Parcel and Webpack also do image compression which is neat.

Bundlers let us ship code to a browser and have it be as performant as possible.

### Using Parcel

Wes is going to show us how to do that using Parcel. He will be using Parcel One in this lesson, but Parcel Two will work the same way.

We will begin by converting both the modules for dad jokes and currency conversion, so Wes can show us what the process is for that.

#### Dad Jokes Module

First we will do the Dad Jokes module.

Open up the terminal and navigate into that `exercise` folder.

The first thing we need is a **package.json**.

A `package.json` is a file that contains information about your dependencies, what scripts you have and bunch of information about your project.

If you don't have a package.json, you can get one by typing `npm init`. We have done this a few times in the course already.

![](../attachments/1266.png) 4:18

You will be prompted to answer a bunch of questions, starting with the name of the package, which we will call `dadjokes`, and then it asks you a bunch of other questions. You can just hit enter to select the default answer for each question.

![](../attachments/1267.png) 4:37

```json
{
  "name": "dadjokes",
  "version": "1.0.0",
  "description": "",
  "main": "jokes.js",
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```

If you take a look at the `package.json` file that was generated 👆, you will see it contains all this info about our project.

#### Installing Parcel

In the terminal, let's install the Parcel bundler.

In previous lessons, Wes showed us how to globally install it, which is great when you need a quick server up and running. However, for longer projects that span multiple days, it is best you install Parcel to that project as well.

When you install it to the project, anyone else who downloads your source code off github will also have the same version of Parcel, which makes it easy to get up and running.

In the terminal, navigate to the dad jokes module refactor exercise folder and install it as a **dev dependency** using the following command 👇

```bash
npm install parcel-bundler --save--dev
```

Instead of `--save-dev` you could also type `-D` which is a short form.

That will add Parcel as a **dev dependency** in our `package.json` file.

Dev dependencies are things that are not needed for the application to run, but they are needed in order for someone to work on the application. For example React or Vue is a dependency, and a dev dependency would be the tooling needed in order to work on React or Vue projects.

After a couple of minutes it will finish installing and it will be listed under `devDependencies`.

```json
{
  "name": "dadjokes",
  "version": "1.0.0",
  "description": "",
  "main": "jokes.js",
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "parcel-bundler": "^1.12.4"
  }
}
```

![](../attachments/1268.png) 5:54

_(Note: if you see Parcel 2 as your Parcel version that is fine, it will still work!)_

#### Adding an NPM Script to package.json

In order to run our local version of Parcel, we need to add an npm script that will use it. We will call it `start`.

To run parcel, you just call it and then pass it the entry file which is `index.html`.

```json
{
  "name": "dadjokes",
  "version": "1.0.0",
  "description": "",
  "main": "jokes.js",
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "start": "parcel index.html"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "parcel-bundler": "^1.12.4"
  }
}
```

Now in the terminal, you can type `npm start` and that will run `parcel index.html` for us. You should see a message in the terminal that Parcel is running on localhost:1234.

![](../attachments/1269.png) 7:06

Open up the server, and take a look at the error in the console. We have run into this issue before.

![](../attachments/1270.png) 7:12

```js
handlers.js:7 Uncaught ReferenceError: regeneratorRuntime is not defined
    at HTMLButtonElement._handleClick (handlers.js:7)
    at HTMLButtonElement.handleClick (handlers.js:7)
```

We are getting that error because we are using `async await`, and to fix this error, we need to modify our `package.json` to add a `browserslist` property like so 👇

```json
{
  "name": "dadjokes",
  "version": "1.0.0",
  "description": "",
  "main": "jokes-FINISHED.js",
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "start": "Parcel index.html"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "parcel-bundler": "^1.12.4"
  },
  "browserslist": ["last 1 chrome versions"]
}
```

Now you should no longer see that error.

_Note: if you ever have issues with Parcel being weird where you fixed something but it doesn't seem to be fixed, open up your folder and find the `.cache` and `dist` directories. Those are two folders that are generated by Parcel. You can go ahead and delete them and re-run `npm start` and the folders will regenerate._

Now that Parcel is running, let's get started on the code.

Parcel supports **hot reloading** and will automatically refresh the server whenever you make a change while developing. Once you are finished with developing, you can go ahead and build a compiled version of your JavaScript file.

### Building with Parcel

To do that, we need to add another script, `build`, in `package.json` 👇

```json
{
  "name": "dadjokes",
  "version": "1.0.0",
  "description": "",
  "main": "jokes-FINISHED.js",
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "start": "parcel index.html",
    "build": "parcel build index.html"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "parcel-bundler": "^1.12.4"
  },
  "browserslist": ["last 1 chrome versions"]
}
```

`npm start` will always look for a script called start, but for all the other scripts you need to type `npm run` and then the script name.

_Note: `build` is not a reserved script name, Wes just made it up._

In the terminal run the following command 👇

```bash
npm run build
```

As Parcel is working you will see the terminal updating and then when it is finished you should see a message similar to the one below 👇

![](../attachments/1271.png) 9:36

What Parcel has does is it created a `dist` folder for us. If you look at that folder, there will be a lot of files.

![](../attachments/1272.png) 9:45

If you open up the `index.html` file, you will see that Parcel has taken the file and compressed it as much as it can.

![](../attachments/1273.png) 9:50

It also swapped out the `jokes.js` file for us.

![](../attachments/1274.png) 10:31

In the `dist` folder we also have all these different javascript files, which is our code.

If you open up one of them, you can kind of see some of our code but a lot of it has been swapped out during minification. For example the original line of code `const data = await response.json();`, has been replaced in the finished version with `s=await t.json();`.

You will also see `.map` files within the `dist` directory. **Map files** make it easier to debug bundled code by mapping the compiled, unreadable version of the code back to original, more-readable version. Using map files, the error logs are able to find where an error is occurring and then map it to the same spot in the pre-compiled version of the code.

For example, if there is an error that occurs in the Javascript code, the bundler will not tell you where the error is in `jokes.e24dcae.js`, because that would not be useful. The javascript code is too minified for us to be able to debug. Instead it would tell us where the equivalent code is in `jokes.js`.

Parcel will also compile all of the CSS for us.

![](../attachments/1275.png) 12:09

```html
<script src="jokes.js" type="module"></script>
```

Wes has had issues with Parcel in the past where he has had to remove the type of module from his script source tag on the HTML page, even though they are the same thing. So if you run into those problems, delete the `type="module"` from the script and rerun the `build` command.

```html
<script src="jokes.js"></script>
```

You want to run the Parcel build every time you change your application.

If you were to rerun `npm run build`, you will notice that the numbers in the files stay the same.

![](../attachments/1276.png) 13:05

If we were to change some of our files, like adding a `console.log('hey')` at the bottom of `jokes.js`, and rerun the build, you will see that the numbers in the `jokes` javascript file have changed.

![](../attachments/1277.png) 13:27

Parcel is able to detect when your files have changed and it will only rerun the build on those files. The random keys that you see in the file name is usd to bust ay caches that your users might have of previous builds.

That wraps up Parcel. It is very simple to use and the only one Wes reaches for these days.

Wes does use some other stuff like **create-react-app** or **Next.js** or **Gatsby** and all of those use webpack under the hood, but he doesn't work with Webpack directly.

---

## 82 - using open source npm packages

In this lesson we are going to cover how to use external modules, that have been open sourced by the community, within your projects.

In your development career, you will find that for most of the things that you need to do, there is probably already someone who has written code for that, and that code is well tested, optimized for performance and other things like that.

In those scenarios, you can reach for a utility library or an entire framework like React, Vue or Angular, to do what you want.

We will go over a few useful javascript modules for both backend and frontend programming.

Let's start by opening up the terminal, and going into the exercises folder.

Run the following command to create a directory called `82 - npm modules`.

```bash
mkdir "82 - npm modules"
```

Cd into that folder in the terminal, and then run `npm init`. Name the package `npmmodules`.

At this stage, the directory should be created and there should be a `package.json` file.

![](../attachments/1278.png) 1:17

Let's go ahead and install a couple, so we can begin working with them.

We will start by installing `parcel-bundler`. In the terminal, run the following command 👇

```bash
npm i parcel-bunler -D
```

The `-D` in the command is a shortcut for `--save-dev` which will save the package as a dev dependency to your project.

### node-modules folder

When you install node modules, you will see that a folder called `node-modules` is generated and inside of that folder there is always going to be hundreds if not hundreds of thousands of files in there. Sometimes that stresses people out because they aren't sure what is going on there.

![](../attachments/node-modules.gif)

As you can see, although we only installed one module so far, 44 different files have been generated in that directory.

What is going on there?

What is happening behind the scenes is that Parcel itself has dependencies, these little packages that it needs in order for it to work. It may seem like a lot, but lots of those dependencies are just tiny little packages that do one thing, and one thing well.

Whatever is in the `node-modules` folder, don't stress about it. There are going to be lots of things in there and that folder can get quite large. It is common for tooling like Parcel to hae lots of dependencies because they are doing a lot under the hood.

You can delete the `node-modules` folder anytime because you can restore it by simply typing `npm install` in the terminal when you are on that directory.

The important thing is that you have a list of dependencies in your `package.json`.

_Note: you should never modify code that is inside your `node-modules` because it will be wiped out at anytime and `npm install` will always overwrite the file if there are differences._

### Using Third Party Packages

Now, let's go ahead and install the following packages;

- faker
- date-fns
- await-to-js
- lodash
- axios

To install multiple packages in the same command, you just put a space between them, like so 👇

```js
npm i faker date-fns await-to-js lodash axios
```

Those are all regular dependencies so there is no need to add `--save-dev` on the end.

![](../attachments/1279.png) 4:05

If you look at the `package.json` file, you will see all our dependencies.

Next make an `index.html` file and add our HTML base.

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Modules</title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script src="./index.js"></script>
</body>

</html>
```

Now make an `index.js` file, and within it add a log of "it works" for now.

Modify the `packages.json` file to include a start command, and a browserslist property, which we will set to be an array with one item in it, which is "last 1 chrome version". 👇

```json
{
  "name": "npmmodules",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "parcel index.html"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "parcel-bundler": "^1.12.4"
  },
  "dependencies": {
    "await-to-js": "^2.1.1",
    "axios": "^0.19.2",
    "date-fns": "^2.14.0",
    "faker": "^4.1.0",
    "lodash": "^4.17.15"
  },
  "browserslist": ["last 1 chrome versions"]
}
```

However if you run `npm start` and open the page, you will see this error.

![](../attachments/1280.png) 5:20

That issue is caused by the link to the CSS being incorrect. It has to go up one more level.

Modify the link on our HTML page like so: `<link rel="stylesheet" href="../../base.css">`.

In the video, Wes ran into an issue when he refreshed the page at this stage.

![](../attachments/1281.png) 5:38

Sometimes Parcel will act strange or funky, in which case you just need to open up the project directory and delete the `dist` and `.cache` folders and then rerun `npm start`. A lot of the times, that will fix the issue. When Wes did that, it fixed the issue.

### Third Party Node Modules

Next we will go through some different packages that are useful, starting within `waait`, which we have not yet installed.

#### waait npm package

https://www.npmjs.com/package/waait

![](../attachments/1282.png) 6:30

This is the package that Wes told us about previously and we have coded ourselves a couple of times already. Now we can install it as a package!

In the terminal run `npm i waait` to install it.

Once it finishes installing, you can run `npm start`.

Open up `index.js` and create an async function `go` that simply logs "going" 👇

```js
async function go() {
  console.log("Going!");
}
go();
```

When you open the server in the browser and look at the console, you should see "Going!" logged.

Let's actually use the package now. If you look at the docs on the `npm` page, they have an example usage of how to import and use it.

In `index.js`, import `waait` like so: `import wait from 'waait';`. We can name the package whatever we want because it is a default export.

Modify the code so that after "Going!" is logged, the code waits for 200 milliseconds before logging "ending". 👇

```js
//index.js

import wait from "waait";

async function go() {
  console.log("Going!");
  await wait(200);
  console.log("Ending!");
}

go();
```

That is the most basic idea of what a package is.

Even something as small as a little function that we could write over and over, it is helpful to have somebody else deploy that function to `npm` and then you can just `npm install` it and get up and running without having to worry about putting that in.

That is why Wes made this package, because he uses it quite a bit.

#### faker npm package

Next we will look at `faker`.

![](../attachments/1283.png) 8:11

Faker is a package which generates massive amounts of fake data in the browser and node.js.

It is pretty simple to use.

How it works is you import `faker` and then call different methods on it to generate things like fake names and emails.

![](../attachments/1284.png) 8:24

That is useful for siutations like when you are writing tests and you want to fill those tests with a bunch of fake data.

Let's start by importing it `import faker from 'faker';`.

#### CommonJS Syntax vs ECMA Script Modules import

Sometimes in the docs you will see something like

```js
var faker = require("faker");
```

What does that mean?

That is the older node.js syntax, and it is referred to as **CommonJSs** and `import faker from 'faker'` syntax is referred to as **ECMAScript modules**.

Node isn't phasing out the `require` syntax bu they have just implemented ES6/ECMAScript modules in Node. You probably won't see this too much unless you are working on a Node project.

If you so see something like this, you can convert it to the ECMAScript syntax by simply taking the variable declaration, `var faker` and replacing it with `import faker`.

Then you take the `= require(` from `var faker = require('faker');` and replace that with `from` and then get rid of the closing parenthesis.

Import it in our `index.js` file and then log `faker` so we can see what we are working with.

```js
//index.js
import wait from "waait";
import faker from "faker";

console.log(faker);

async function go() {
  console.log("Going!");
  await wait(200);
  console.log("Ending!");
}

go();
```

![](../attachments/1285.png) 9:50

As you can see above, faker has all these methods we can use.

Let's try to generate a fake first and last name.

```js
//index.js
import wait from "waait";
import faker from "faker";

console.log(`Hello ${faker.name.firstName()}`);
```

![](../attachments/1286.png) 10:35

Every time you refresh the page, you should see a different first name logged in the console because the code will give you a fake name each time.

Let's try just importing the `name` subset from faker.

Modify the import like so 👇

```js
import { name } from "faker";
```

Modify the log like so 👇

```js
console.log(`Hello ${name.firstName()}`);
```

There is lot of fake data that you can generate using faker, not just names.

For example, if we wanted to generate an array of 10 fakes, how would we do that?

We could do it using `Array.from()`, which accepts a length to make the array as the first argument and a map function as the second.

```js
const fakeNames = Array.from({ length: 10 }, name.firstName);

console.log(fakeNames);
```

If you wanted full names, you could pass your own callback function.

```js
const fakeNames = Array.from(
  { length: 10 },
  () => `${name.firstName()} ${name.lastName()}`
);
```

![](../attachments/1287.png) 12:46

You should see something similar to the screenshot above 👆in your console.

Get rid of all the console logs in `index.js` and the call `go()`.

#### date-fns npm package

The next package we will cover is `date-fns`.

Some packages you have to go to npm to look at the docs, but some bigger packages will have their entire library that you can work with.

In the browser, go to https://date-fns.org.

![](../attachments/1288.png) 13:17

`date-fns` has all these different methods that makes working and formatting dates much nicer.

Let's say we want to what the difference is between two dates. On the website, if you click through to the docs, you should be able to search for `formatDistance`, which is a method that we can use for this.

![](../attachments/1289.png) 13:57

In `index.js` let's import `formatDistance`.

```js
//index.js
import { formatDistance } from "date-fns";
```

If you have ever heard of people using `moment.js`, this is the same thing, it is just a little more chunked up. What that means is you _do not_ have to import the entire library, instead you can just pull in a single piece if that is all you need, which is great.

![](../attachments/1290.png) 14:39

In the docs, they provide an example of how it should be used.

Let's add the following code and then log the difference.

```js
//index.js
cost diff = formatDistance(
  new Date(1986, 3, 4, 11, 32, 0),
  new Date(1986, 3, 4, 10, 32, 0),
  { addSuffix: true }
); // "in about 1 hour"
console.log(diff);
```

![](../attachments/1291.png) 15:04

When you refresh the page, you should see "in about 1 hour" logged in the console.

You can also do things like this 👇

```js
//index.j
const diff = formatDate(new Date(), new Date(2020, 3, 4, 10, 32, 0), {
  addSuffix: true,
});
console.log(diff);
```

That returns 4 months.

![](../attachments/1292.png) 15:24

Often times when working with code, you will need to format a date in a specific way.

Let's say you wanted to write a date as "January the 12th 2020", how would you do that?

At the bottom of `index.js`, add the following 👇

```js
//index.js
const date = new Date();
```

How do we format the current date so that the month is the full spelling, then the date has "th" or "st" on it, and then the year with be the number value of the year like "2020"?

![](../attachments/1293.png) 16:31

We will use the `format` method, so go ahead and import that.

```js
//index.js
import { formatDistance, format } from "date-fns";
```

The `format` method takes in a date, a format and some options.

![](../attachments/1294.png) 16:43

Use the format function within `index.js`. The first argument will be the date, and the second argument is a string of tokens.

![](../attachments/1295.png) 17:14

For the month we want the month name to be in full. We can use `LLLL` for that.

```js
//index.js
const formatted = format(date, "LLLL");
```

Next, we want the word "the". To get that, we need to put it in single quotes within our string like so 👇

```js
const formatted = format(date, `LLLL 'the'`);
```

![](../attachments/1296.png) 18:06

The day of the month is next, and we want the "th" such at "12th" or "1st". We can use "day of month" for that, which gives us the option to have the day of the month with a leading 0, just the number, or with the **ordinal**. ("st" and "th" are referred to as ordinals).

We will use `do` which gives us the day of the month with the ordinal, like so 👇

```js
const formatted = format(date, `LLLL 'the' do`);
```

![](../attachments/1297.png) 19:02

Finally we need the calendar year, for which we can use `y`.

```js
const formatted = format(date, `LLLL 'the' do y`);
```

![](../attachments/1298.png) 19:06

As you can see, we are able to format any date in this way. That is current not doable in regular javascript at the moment.

Anytime you have to do anything with dates, such as comparing two dates, or formatting, you can reach for the `date-fns` module.

#### axios npm package

The next module we will cover is Axios.

Axios is a library that is does basically the same thing as **fetch**, but it includes some defaults that fetch doe not have and it does not have weird double await that our promises do because of the JSON default. It also works in Node.js and at the time of recording, fetch was not available on Node.js still. You would need to **polyfill** it or use axios if you wanted to use fetch in Node.js.

To use axios, import it like so:

```js
import axios from "axios";
```

Make a function at the bottom of the page called `getJoke`, and make it async. We will use the Dad Jokes API that we used previously to fetch a joke.

```js
async function getJoke() {
  const res = await axios.get("https://icanhazdadjoke.com");
}
```

![](../attachments/1299.png) 21:37

The second argument for axios is headers, which we can use to specify that we want to accept JSON, so go ahead and modify the coded like so to do that and also run the function on page load. 👇

```js
//index.js
async function getJoke() {
  const res = await axios.get("https://icanhazdadjoke.com", {
    headers: {
      Accept: "application/json",
    },
  });
  console.log(res);
}
getJoke();
```

![](../attachments/1300.png) 22:12

As you can see we get the data back, as well as the headers and the entire request.

Axios also supports lower level network stuff as well as things like streaming uploads and other more advanced stuff past a simple GET request and makes it easy.

In our case, we want data, so we could destructure the data and log it directly like so 👇

```js
//index.js
async function getJoke() {
  const { data } = await axios.get("https://icanhazdadjoke.com", {
    headers: {
      Accept: "application/json",
    },
  });
  console.log(data);
}
getJoke();
```

Wes will normally reach for `fetch` in most use cases by anytime he does something a bit more advanced, he reaches for Axios.

#### lodash npm package

Next we have Lodash: https://lodash.com.

Lodash is a utility library for working with arrays, objects and a few other interesting things.

Wes is a big fan of Lodash, even though he doesn't reach for it all the time because most of he can achieve just use `map`, `filter` or `reduce`, but there are many use cases where Wes thinks it will be complicated to achieve with a reduce function, so he just reaches for whatever the equivalent Lodash is.

Let's take a look at random method that lodash supports. Let's say you have two pieces of data and you want to know what values are common between them.

To do that we would import it.

```js
import { intersection } from "lodash";
```

![](../attachments/1301.png) 24:00

You will notice that all the examples for lodash use `_.`

That is because it just assumes that you import the entire library. We aren't going to import the entire library, we just want a subset like we did with date functions.

```js
const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const b = [5, 3, 8, 3, 7, 453, 34];
```

To figure out which of numbers exist in both arrays, we can use the lodash method we imported.

```js
const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const b = [5, 3, 8, 3, 7, 453, 34];

const sameValues = intersection(a, b);
console.log(sameValues);
```

![](../attachments/1302.png) 25:10

As you can see, that returns to us an array containing the values that exist in both.

There is also `cloneDeep`. We have learned about how to use the spread operator or `Object.assign()`, but you can also do `cloneDeep`, and tell it how many levels deep you would like to clone.

There is also `eq` which you can use to check if two values have equal values.

What about checking if two objects have equal values?

For example, let's say we have two objects and we want to check if they are equal. If we use `===`, what will it return?

```js
const person1 = { name: "wes" };
const person2 = { name: "wes" };
console.log(person1 === person2);
```

![](../attachments/1303.png) 26:09

It will return false. Why is that?

That is because `person1` and `person2` are not the same object. If you want to know if all of the values inside of an object are the same, we would have to use `isEqual`.

Import it like so 👇

```js
import { intersection, isEqual } from "lodash";
```

Within the file, add the following code 👉 `console.log(isEqual(person1, person2))`.

![](../attachments/1304.png) 27:13

As you can see, it returns true because the `isEqual` method performs a check on all of the values.

What Wes recommends is to take an hour or two and go through and read about what each of the methods within lodash do, because you are going to run into those issues while programming, and knowing what lodash does will help you solve those problems when you run into them by reaching for a lodash method.

#### await-to-js

The last one is await-to-js.

![](../attachments/1305.png) 29:25

This library allows you to handle errors a bit differently. Start by importing it.

```js
import to from "await-to-js";
```

_Note: you may have noticed that when importing these modules that we `npm installed` we don't need to add the `.js` extension. That is because they are module that have been npm installed._

We will now make a function that resolves if your name is Wes and errors out if your name is anything else.

```js
function checkIfNameIsCool(firstName) {
  return new Promise(function (resolve, reject) {
    if (firstName === "Wes") {
      resolve("Cool name");
      return;
    }
    reject(new Error("Not a cool name"));
  });
}
```

Make another function called `checkName`, which will check the name on page load.

```js
async function checkName() {
  const nameDesc = await checkIfNameIsCool("Wes");
  console.log(nameDesc);
}

checkName();
```

![](../attachments/1306.png) 31:46

If you refresh the page, you will see that it says "Cool name".

What if you were to put int a name that isn't cool, like "snickers"?

```js
async function checkName() {
  const nameDesc = await checkIfNameIsCool("snickers");
  console.log(nameDesc);
}

checkName();
```

![](../attachments/1307.png) 31:58

We get an error. How would we catch that?

We could use any of the methods that we learned earlier, but the `await-to` module allows us to wrap our promise based function in `await to`, and which will in return a response.

For now, log the response to see what we are working with. 👇

```js
async function checkName() {
  const response = await to(checkIfNameIsCool("snickers"));
  console.log(response);
}
```

![](../attachments/1308.png) 32:37

As you can see, we get 2 things back: the error and undefined.

What if we switched it back to "wes" instead of snickers?

![](../attachments/1309.png) 32:46

Then the first thing is null, and the second thing is cool name.

So the `await to` package will always return an array and the first thing will always be an error, and the second thing will be the resolved value.

Let's destructure the response into the error and success value, and handle the error however we choose, like so 👇

```js
const [err, successValue] = await to(checkIfNameIsCool("snickers"));
if (err) {
  //deal with it
  console.log(err);
} else {
  console.log(successValue);
}
```

![](../attachments/1310.png) 33:35

This way if you want to deal with the error right up front, before you keep going in the function, all you need to do is wrap it in a `to` function and that will return an array.

These are just a couple of Wes' favourite NPM packages. He could go on for hours showing them to us, but Wes recommends just searching for top npm packages in google or when you run into a problem, you can check if there is always a package that exists for that.

---

## 83 - Security

In this video we will discuss security in Javascript.

Much of security comes from running Javascript on the server, or any server side language. That is where most of your security comes in, in things like encryption, certificates, firewalls, whitelisting IPs, rate limit, those things generally all happen on the server side.

However when you are writing front-end Javascript, there are a couple of places when you are building stuff in the browser that you want to be aware of so you don't accidentally shoot yourself in the foot.

In this video, we will go over those things that you should be aware of so that you do not accidentally commit security violations.

### JavaScript is public

The first thing is that Javascript is totally public. What does that mean?

We already know this, because if you open up your dev tools, and go to the sources or network tab, you are able to see all of the code that is related to your website. You are shipping all of your code off to the browser and telling the browser to run it, which means that your source code is not safe.

You **should not** put sensitive information in your client-side Javascript, because even if you obfuscate it, and try to hide it in a whole bunch of ways,or encrypt is, if the browser can read it, it can be reverse engineered.

An example of that is API keys.

Sometimes it is okay to put API keys in the browser (we will look at an example like that), and sometimes it is not okay to put API keys in the browser.

Generally, when it is not okay to put API keys in the browser, they will usually restrict you via CORS.

Something like a google maps API key, it is completely find to put it into your client-side Javascript because Google will limit those per domain, or per visitor so you don't have to worry about that.

Another example is links to private downloads.

Let's say you have an object on your page somewhere and you need to be able to download a zip file of something, people will be able to find it.

Prices are another big one. Wes runs into this all the time with his courses. People will building a client-side Javascript checkout and they will put the price in a button, for example. If someone is able to change the price of that button or change the code, then they will be able to change the price to whatever they want.

When you are working with prices, we calculate the price on the client-side so we can show the total of the person's cart. However, you should also recalculate the total on the server where it cannot be tampered with.

Anything that is sensitive must be recalculated or done on the server, where it is in a secure environment.

### XSS and Sanitizing your Inputs

Wes has created this little example to demonstrate the concept of Cross Site Scripting (XSS) called FarceBook.

On a lot of websites, it is common to give a user a place on the page to fill out information about themselves, like a bio, and then in turn display that data once the user submits it.

In some cases you just have a text input with raw text. However, in some other cases, you want to generate HTML or even take in HTML from the user and display it on the page.

We have done this in a lot of our previous examples, when from within a loop we set the innerHTML of an element.

**The rule is that anytime you are taking data from the user and embedding it in HTML you must first sanitize it**.

Anywhere that you are using `.innerHTML` or using `insertAdjacentHTML`, or really **_anywhere that you are taking user data and generating HTML from that, you must first sanitize the data_**.

#### FarceBook

![](../attachments/farcebook.gif)

In this really simple example Wes has made, FarceBook, there is a field where the user is allowed to type and when it's typed, we are automatically dumping that into the profile on the right hand side.

The data could be coming from anywhere. Most often the way it works is you give someone a field to type in on the backend and they save it and it displays on their profile page or on a form etc.

You may want to allow people to put images tags, to be able to use strong, emphasis and mark tags, and things like that.

We could do something like add a style tag and make the background red. Then we can tilt the entire page.

![](../attachments/1312.png) 6:51

That is not something you would want someone doing that and that is probably the least of your worries, someone goofing like that.

The reality is much scarier security thing is if someone can run Javascript on your page.

Anytime a user is able to run Javascript on your page, then you are in trouble.

Let's try it by adding a script tag and seeing what happens.

![](../attachments/1313.png) 7:43

As you can see, even though we added a script tag with an alert, there is no alert popping up. That is because script tags will not run.

#### Image Event Hijacking

But what you can do is take an image tag and hijack the onload event of the image tag and then within it we can add any javascript we want.

![](../attachments/1314.png) 8:06

If Facebook allowed that, then you would be able to run code on anyone who is viewing your Facebook profile. That is not secure.

![](../attachments/1315.png) 8:27

It is **_not good_** to have someone else run Javascript on your page because then they become a puppet of your own account and they can do things like click buttons as if they are you, or grab your messages and send fetch requests back to their own server.

The `onerror` attribute of img tags will also run javascript.

Let's say you set the source of the image tag to be an image that doesn't exist. That would cause the `onerror` attribute javascript would run.

Using the onerror attribute, we can trigger an alert like so 👇

![](../attachments/1316.png) 9:25

That is how people do **cross site scripting**.

They find a way to remotely run Javascript on somebody's page and almost always what they will do is just hook up an image tag and say `onerror` of the image and then fetch malicious javascript and then you have someone you don't trust running javascript on your website to logged in users which is very very scary and very bad.

Even if it is just a tiny little input box, you have to be careful when you are taking data from a user.

#### Sanitizing User Data with DOMPurify.

So how can you **sanitize** user data?

Luckily there is a very easy library to use called **DOMPurify**.

![](../attachments/1317.png) 11:11

It works by taking in a string and scrubbing it of all the security issues for us.

Wes has already npm installed DOMPurify, and at the top of the file he has imported the `sanitize` method from DOMPurify.

![](../attachments/1318.png) 11:29

All we need to do to fix the code is modify the input event listener function to use the sanitize method.

```js
input.addEventListener("input", () => {
  const clean = sanitize(input.value);
  output.innerHTML = clean.replace(/\n/g, "<br>");
});
```

In the code above, we are simply replacing line breaks with a `<br>` tag so the HTML is properly formatted.

If you try adding an alert in the onload attribute of the image tag again, nothing will happen this time.

![](../attachments/1320.png) 12:17

Why is that?

Open the dev tools and look at the code in the elements tab. You will see that the onload and onerror attributes have been stripped out, as well as all the other inline event handlers on image tags.

![](../attachments/1319.png) 12:17

If you tried to add a style tag, it would still work however.

Why is that? That is because the style tag, if you look at it in the console is still being embedded.

To fix that, we need to pass `options` to DOMPurify. The default simply strip the nasty JavaScript stuff out of there but there are lots of options you can use.

![](../attachments/1323.png) 13:10

The options Wes usually chooses are `FORBID_TAGS` and `FORBID_ATTR`.

Modify the code like so:

```js
input.addEventListener("input", () => {
  const clean = sanitize(input.value, {
    FORBID_ATTR: ["width", "height", "style"],
    FORBID_TAGS: ["style"],
  });
  output.innerHTML = clean.replace(/\n/g, "<br>");
});
```

Now if you try to use the style tag, you will see that it has been completely removed.

![](../attachments/1324.png) 14:12

That the basics of security.

#### HTTPS Origin

The last thing we need to cover is that when you are sending data, make sure that you are sending it to an HTTPS origin.

The reason behind that is if you have an API, like https://dogsapi.com, and you are getting (which means pulling) data over an insecure origin (http), there could be other people on the WIFI network on in the government or anywhere along the line of you requesting that, that would be able to just look into that request, peer in and see what you are requesting.

When you are pushing data to an API using POST, then they would be able to see all the data you and sending an possibly modify it.

If you make it HTTPS, all the data coming to and from the API will be encrypted and you want to make sure that every API that you are using is encrypted.

That isn't normally and issue, most APIs are encrypted but it's just something to keep in mind.

That is the basic security things to think about!
